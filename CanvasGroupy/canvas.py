# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/api/03_canvas_group_creation.ipynb.

# %% auto 0
__all__ = ['bcolors', 'CanvasGroup']

# %% ../nbs/api/03_canvas_group_creation.ipynb 3
from canvasapi import Canvas
import canvasapi
import json
import requests
import time
import sys
import numpy as np
import pandas as pd
from io import StringIO

# %% ../nbs/api/03_canvas_group_creation.ipynb 4
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

# %% ../nbs/api/03_canvas_group_creation.ipynb 5
class CanvasGroup():
    def __init__(self,
                 credentials_fp = "", # credential file path. [Template of the credentials.json](https://github.com/FleischerResearchLab/CanvasGroupy/blob/main/nbs/credentials.json)
                 API_URL="https://canvas.ucsd.edu", # the domain name of canvas
                 course_id="", # Course ID, can be found in the course url
                 verbosity=0 # Controls the verbosity: 0 = Silent, 1 = print all messages
                ):
        "Initialize Canvas Group within a Group Set and its appropriate memberships"
        self.API_URL = API_URL
        self.canvas = None
        self.course = None
        self.group_category = None
        self.group_categories = None
        self.groups = None
        self.users = None
        self.email_to_canvas_id = None
        self.canvas_id_to_email = None
        self.API_KEY = None
        self.GitHubToken = None
        self.verbosity = verbosity
        
        # initialize by the input parameter
        if credentials_fp != "":
            self.auth_canvas(credentials_fp)
        if course_id != "":
            self.set_course(course_id)
            self.get_group_categories()
            
    def auth_canvas(self,
                    credentials_fp: str # the Authenticator key generated from canvas
                   ):
        "Authorize the canvas module with API_KEY"
        with open(credentials_fp, "r") as f:
            credentials = json.load(f)
        self.API_KEY = credentials["Canvas Token"]
        self.GITHUB_TOKEN = credentials["GitHub Token"]
        self.canvas = Canvas(self.API_URL, self.API_KEY)
        # test authorization
        _ = self.canvas.get_activity_stream_summary()
        if self.verbosity != 0:
            print(f"{bcolors.OKGREEN}Authorization Successful!{bcolors.ENDC}")
        
    def set_course(self, 
                   course_id: int # the course id of the target course
                  ):
        "Set the target course by the course ID"
        self.course = self.canvas.get_course(course_id)
        if self.verbosity != 0:
            print(f"Course Set: {bcolors.OKGREEN} {self.course.name} {bcolors.ENDC}")
            print(f"Getting List of Users... This might take a while...")
        self.users = list(self.course.get_users())
        if self.verbosity != 0:
            print(f"Users Fetch Complete! The course has {bcolors.OKBLUE}{len(self.users)}{bcolors.ENDC} users.")
        self.email_to_canvas_id = {}
        self.canvas_id_to_email = {}
        for u in self.users:
            try:
                self.email_to_canvas_id[u.email.split("@")[0]] = u.id
                self.canvas_id_to_email[u.id] = u.email.split("@")[0]
            except Exception:
                if self.verbosity != 0:
                    print(f"{bcolors.WARNING}Failed to Parse email and id"
                          f" for {bcolors.UNDERLINE}{u.short_name}{bcolors.ENDC}{bcolors.ENDC}")
                
        
    def set_group_category(self,
                           category_name: str # the target group category
                          ) -> canvasapi.group.GroupCategory: # target group category object
        _ = self.get_group_categories()
        try:
            self.group_category = self.group_categories[category_name]
        except KeyError:
            raise KeyError(f"{category_name} did not found in the group categories. "
                           f"Try to create one with CanvasGroup.create_group_category")
        return self.group_category
        
    def get_course(self):
        return self.course
    
    def get_group_categories(self) -> dict: # return a name / group category object
        "Grab all existing group category (group set) in this course"
        categories = list(self.course.get_group_categories())
        self.group_categories = {cat.name: cat for cat in categories}
        return {cat.name: cat for cat in categories}
    
    def create_group_category(self,
                              params: dict # the parameter of canvas group category API @ [this link](https://canvas.instructure.com/doc/api/group_categories.html#method.group_categories.create)
                             ) -> canvasapi.group.GroupCategory: # the generated group category object
        "Create group category (group set) in this course"
        self.group_category = self.course.create_group_category(**params)
        return self.group_category
    
    def create_group(self,
                     params: dict, #the parameter of canvas group create API at [this link](https://canvas.instructure.com/doc/api/groups.html#method.groups.create)
                    ) -> canvasapi.group.Group: # the generated target group object
        "Create canvas group under the target group category"
        if self.group_category is None:
            raise ValueError("Have you specified or create a group category (group set)?")
        group = self.group_category.create_group(**params)
        if self.verbosity != 0:
            print(f"In Group Set: {bcolors.OKBLUE+self.group_category.name+bcolors.ENDC},")
            print(f"Group {bcolors.OKGREEN+params['name']+bcolors.ENDC} Created!")
        return group
    
    def join_canvas_group(self,
                          group: canvasapi.group.Group, # the group that students will join
                          group_members:[str], # list of group member's SIS Login (email prefix, before the @.)
                         ) -> [str]: # list of unsuccessful join
        "Add membership access of each group member into the group"
        unsuccessful_join = []
        for group_member in group_members:
            try:
                canvas_id = self.email_to_canvas_id[group_member]
                group.create_membership(canvas_id)
            except KeyError:
                unsuccessful_join.append(group_member)
                print(f"Error adding student {bcolors.WARNING+group_member+bcolors.ENDC} \n into group {group.name}")
            group.create_membership(canvas_id)
        return unsuccessful_join
    
    def fetch_username_from_quiz(self,
                                 quiz_id: int, # quiz id of the username quiz
                                 csv_name="github_id.csv", # csv output name.
                                 col_index=7, # canvas quiz generated csv's question field column index
                                ) -> dict: # {SIS Login ID: github} dictionary
        "Fetch the GitHub user name from the canvas quiz"
        header = {'Authorization': 'Bearer ' + self.API_KEY}
        quiz = self.course.get_quiz(quiz_id)
        if self.verbosity != 0:
            print(f"Quiz: {bcolors.OKGREEN+quiz.title+bcolors.ENDC} "
                  f"fetch! \nGenerating Student Analaysis..."
                 )
        report = quiz.create_report("student_analysis")
        progress_url = report.progress_url
        completed = False
        while not completed:
            status = requests.get(progress_url, headers = header).json()
            if self.verbosity != 0:
                self._progress(status["completion"])
                time.sleep(0.1)
            if status["completion"] == 100:
                completed = True
        if self.verbosity != 0:
            print(f"\n{bcolors.OKGREEN}Report Generated!{bcolors.ENDC}")
        # use requests to download the file 
        file_url = quiz.create_report("student_analysis").file["url"]
        response = requests.get(file_url, headers=header)
        file = StringIO(response.content.decode())
        # use pandas to parse the response csv
        df = pd.read_csv(file, delimiter=",")
        col = list(df.columns)
        # rename column
        if self.verbosity != 0:
            print(f"The Question asked is {bcolors.OKBLUE}{col[col_index]}{bcolors.ENDC}. \n"
                  f"Make sure this is the correct question where you asked student for their GitHub id.\n"
                  f"If you need to change the index of columns, change the col_index argument of this call."
                 )
        col[col_index] = "GitHub ID"
        df.columns = col
        small = df[["id", "GitHub ID"]].copy()
        small["email"] = small["id"].apply(lambda x: self.canvas_id_to_email[x])
        small = small[["email", "GitHub ID"]].set_index("email")
        small.to_csv(csv_name)
        return small.to_dict()["GitHub ID"]
    
    def check_github_username(self,
                              github_username: str # the student input we want to test
                             ):
        ...

    def _progress(self,
                  percentage
                 ):
        sys.stdout.write('\r')
        # the exact output you're looking for:
        sys.stdout.write("[%-20s] %d%%" % ('='*int(percentage//5), percentage))
        sys.stdout.flush()
    
    def assign_canvas_group(self,
                            group_name: str, # group name, display on canvas
                            group_members:[str], # list of group member's SIS Login
                            in_group_category: str, # specify which group category the group belongs to
                           ) -> (canvasapi.group.Group, [str]): # list of unsuccessful join
        "Create new groups and assign group member into the class in the `self.group_category`"
        self.set_group_category(in_group_category)
        group = self.create_group({"name": group_name})
        unsuccessful_join = self.join_canvas_group(group, group_members)
        return group, unsuccessful_join

